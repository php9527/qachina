
-----------------------------------------------------------------------------
/*
gcc -o src src.S -Wall -g -nostdlib -Wa,-mmnemonic=intel,-msyntax=intel,-mnaked-reg -m32
*/

//buffer	resb 10000

.global _start
_start:
	nop	//make ld happy

_write:
	mov eax, 4	//set syswrite
	mov ebx, 1	//set stdout
	lea ecx, str	//set text out
	lea edx, strLen	//how much text out
	int 0x80		//make the syscall

_normEnd:
	mov eax, 1	//ready syscall
	mov ebx, 0	//no problem return code

str: .string "hello\n"
	 .equ strLen, 6

-----------------------------------------------------------------------------
.use GDB as C's REPL

% gdb ./test
(gdb) break main
Breakpoint 1 at 0x8048452

(gdb) run
Starting program: /home/pcl/sandbox/test
Breakpoint 1, 0x08048452 in main ()

(gdb) set $a = malloc(1234)
(gdb) call sprintf($a, "Hello %d", 12345*12345*12345)
$1 = 15

(gdb) print (char*)$a
$2 = 0x96c6008 "Hello 170287977"

(gdb) print (unsigned int)atoi("-1")
$3 = 4294967295

(gdb) print (unsigned int)atoi("4294967295")
$4 = 2147483647

-----------------------------------------------------------
(gdb) print 1 + 2
$1 = 3

(gbd) print (int) 2147483648
$2 = -2147483648

(gdb) print &i
$5 = (int *) 0x7fff5fbff584

(gdb) print sizeof(int)
$7 = 4
(gdb) print sizeof(double)
$8 = 8

The flags indicate that I want to examine 4 values, formatted as hex numerals, one byte at a time.
(gdb) x/4xb &i
0x7fff5fbff584: 0x39    0x05    0x00    0x00

(gdb) set var i = 0x12345678
(gdb) x/4xb &i
0x7fff5fbff584: 0x78    0x56    0x34    0x12

-----------------------------------------------------------
(gdb) ptype i
type = int
(gdb) ptype &i
type = int *
(gdb) ptype main
type = int (void)

-----------------------------------------------------------
int a[] = {1,2,3};

(gdb) print a
$1 = {1, 2, 3}
(gdb) ptype a
type = int [3]

(gdb) x/12xb &a
0x7fff5fbff56c: 0x01  0x00  0x00  0x00  0x02  0x00  0x00  0x00
0x7fff5fbff574: 0x03  0x00  0x00  0x00

(gdb) print sizeof(a)
$2 = 12

(gdb) print a + 1
$3 = (int *) 0x7fff5fbff570

(gdb) x/4xb a + 1
0x7fff5fbff570: 0x02  0x00  0x00  0x00

(gdb) print a[0]
$4 = 1
(gdb) print *(a + 0)
$5 = 1
(gdb) print a[1]
$6 = 2
(gdb) print *(a + 1)
$7 = 2
(gdb) print a[2]
$8 = 3
(gdb) print *(a + 2)
$9 = 3

(gdb) x/4xb a
0x7fff5fbff56c: 0x01  0x00  0x00  0x00
(gdb) x/4xb &a
0x7fff5fbff56c: 0x01  0x00  0x00  0x00

(gdb) ptype &a
type = int (*)[3]

(gdb) print a + 1
$10 = (int *) 0x7fff5fbff570
(gdb) print &a + 1
$11 = (int (*)[3]) 0x7fff5fbff578

-----------------------------------------------------------
gdb	启动gdb进行调试
gdb-many-windows	切换单窗格/多窗格模式
gdb-restore-windows	恢复窗格布局

添加断点	gud-break	C-x C-a C-b 或 C-x <SPC>
删除断点	gud-remove	C-x C-a C-d
运行/继续程序	gud-go	无
单步执行，无视函数	gud-next	C-x C-a C-n
单步执行，进入函数	gud-step	C-x C-a C-s
跳出当前函数	gud-finish	C-x C-a C-f
运行到光标所在语句	gud-until	C-x C-a C-u
继续运行程序	gud-cont	C-x C-a C-r

(add-hook 'gdb-mode-hook '(lambda ()
                            (define-key c-mode-base-map [(f5)] 'gud-go)
                            (define-key c-mode-base-map [(f7)] 'gud-step)
                            (define-key c-mode-base-map [(f8)] 'gud-next)))


(defun quick-compile ()
 "A quick compile funciton for C++"
 (interactive)
 (compile (concat "g++ " (buffer-name (current-buffer)) " -g -pg"))
 )
 ;;快捷键F9
 (global-set-key [(f9)] 'quick-compile)


從另一台電腦連上正在跑重要程式的工作站
用ps和grep找出那個程式的pid
用gdb attach它: gdb [program] [pid]
在gdb內輸入: handle SIGHUP nopass 
把當掉的windows重新開機，在gdb內輸入continue讓程式繼續執行
你會看到gdb攔截到SIGHUP的訊息，再輸入continue就可以了


#!/bin/sh
export DISPLAY=tivf09:1.0; xterm -e gdb RIM_Oracle_Agent.binary
如果你的程序在exec的时候还传入了参数，可以改成：
#!/bin/sh
export DISPLAY=tivf09:1.0; xterm -e gdb --args RIM_Oracle_Agent.binary $@ 

-----------------------------------------------------------------------------
echo "cont" > attach.gdb
gdb attach $1 -x attach.gdb

gdb attach $(pidof process_name) -ex cont

-----------------------------------------------------------------------------
% gdb httpd -c core
(gdb) where
it will (hopefully) print a stack backtrace of where the core dump occurred during processing.

x/x 以十六进制输出
x/d 以十进制输出
x/c 以单字符输出
x/i  反汇编 – 通常，我们会使用 x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器）
x/s 以字符串输出

-----------------------------------------------------------------------------
runstack.sh
#!/bin/sh
if test $# -ne 2; then
   echo "Usage: `basename $0 .sh` <process-id> cmd" 1>&2
   echo "For exampl: `basename $0 .sh` 1000 bt" 1>&2
   exit 1
fi
if test ! -r /proc/$1; then
   echo "Process $1 not found." 1>&2
   exit 1
fi
result=""
GDB=${GDB:-/usr/bin/gdb}
# Run GDB, strip out unwanted noise.
result=`$GDB --quiet -nx /proc/$1/exe $1 <<EOF 2>&1
$2
EOF`
echo "$result" | egrep -A 1000 -e "^\(gdb\)" | egrep -B 1000 -e "^\(gdb\)"
-----------------------------------------------------------------------------
set logging on
bt
set logging off
-----------------------------------------------------------------------------
$pkg-config --cflags xft
-D_THREAD_SAFE -I/usr/local/include/freetype2 -I/usr/local/include  
$pkg-config --libs xft
-L/usr/local/lib -lXft  
-----------------------------------------------------------------------------
So write it out to a file instead:
(gdb) p creat("/tmp/somefile.dat", 0777)
$26 = 37
(gdb) p write(37, s, len)
$27 = 168
(gdb) p close(37)
-----------------------------------------------------------------------------

